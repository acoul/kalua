#!/bin/sh

DIR_DATABASE='/database/DB'

_db_check()
{
	local funcname='db_check'
	local option="$1"
	local statfile="/tmp/$funcname"
	local file line i

	[ "$option" = 'force' ] || _db lock now "$funcname() $*" || return 1
	_stopwatch start "$funcname"

	# TODO: check for "VAR=';" (not closed)
	for file in $DIR_DATABASE/USER/device/rows $DIR_DATABASE/USER/device/stats $DIR_DATABASE/USER/login/rows $DIR_DATABASE/USER/profile/rows; do {
		_log do $funcname daemon info "eval-ing each line in '$file', in case of an error: check '$statfile'"

		i=0
		sh -n "$file" || {
			# very slow loop:
			while read line; do {
				i=$(( $i + 1 ))
				echo "file: $file lineno: $i line: $line" >"$statfile"
				eval $line
			} done <"$file"
		}

		[ $i -eq 0 ] && i=$( _file lines "$file" )
		_log do $funcname daemon info "[OK] file '$file' / $i lines"
	} done

	[ "$option" = 'force' ] || _db lock free
	rm "$statfile"

	_log do $funcname daemon info "[OK] lasts $( _stopwatch stop "$funcname" humanreadable )"
	return 0
}

_db_lock()
{
	local funcname="db_lock"
	local mode="$1"			# now|free|reason
	local context="${2:-unset_context}"
	local dir="/tmp/$funcname"
	local file="$dir/reason"
	local i=1

	case "$mode" in
		'reason')
			cat "$file"
		;;
		'free')
			if [ ! -e "$DIR_DATABASE/USER/login/rows" -a -e "$DIR_DATABASE/USER/login/meta_index" ]; then
				if [ $( _file size "$DIR_DATABASE/USER/login/meta_index" ) -eq 0 ]; then
					# ok, e.g. special decentral auth
					rm -fR "$dir"
				else
					# fixme! why can this happen?
					# we dont unlock here - needs admin interaction
					_log do $funcname daemon sms "missing userDB"
				fi
			else
				rm -fR "$dir"
			fi
		;;
		'now'|'forever'|*)
			case "${mode}-${context}" in
				'forever-locked_forever'*)
					echo "$context" >"$file"
					return 1
				;;
			esac

			while ! mkdir "$dir"; do {
				read reason <"$file"
				_log do $funcname daemon info "task '$context' must wait $i sec for '${reason:-unknown_reason}'"

				case "$reason" in
					'locked_forever'*)
						return 1
					;;
				esac

				if _file age "$file" -gt 18000 ; then
					_log do $funcname daemon alert 'autorecover: after 5 hours there must be something wrong'
					break
				else
					_watch monitoring
					sleep $i
					i=$(( $i + 1 ))
				fi
			} done

			# FIXME! because of $* it looks like:
			# 'db_user() login index_gen            _Fri Mar 20 09:09:38 CET 2015'
			echo "${context}|$( date )" >"$file"
			[ $i -gt 30 ] && _log do $funcname daemon alert "longlock: task '$context' looped $i times for '${reason:-unknown_reason}'"
		;;
	esac

	return 0
}

_db_purge()
{
	local funcname="db_purge"
	local obj serverfile identity

	_db lock now "$funcname() $*" || return 1

	for obj in 	"$DIR_DATABASE" \
			'/www/cgi-bin/db_backup.tgz' \
			'/www/cgi-bin/db_backup.tgz.hashlastsend' \
			'/tmp/USERDB_COPY.cgi.gz'; do {
		_log do $funcname daemon info "[OK] removing '$obj'"
		rm -fR "$obj"
	} done

	_db lock free

	identity='/etc/dropbear/dropbear_dss_host_key'
	identity="$( _file hash "$identity" )"
	serverfile="/var/www/networks/${CONFIG_PROFILE%_*}/vds/db_backup.tgz_${identity}.*"
	_log do $funcname daemon info "please manually remove '$serverfile'"
}

_db_backup()		# fixme! automatically call this after <prio> changes
{
	local funcname="db_backup"
	local reason="$1"	# e.g.
				# force				*
				# remove_old_stuff		*
				# index_generated_last1
				# index_generated_full
				# profile_added_or_changed	*
				# tickets_autogenerated		*
				# netfilter_stop		*
				# prepare_copy_to_server
				# minor_update_user_foo
				# login_update_index_gen_last1
	local file="/www/cgi-bin/db_backup.tgz"
	local file_temp="/$funcname/db_backup.tgz.temp.$$"
	local file_safewrite="$file.safewrite"
	local errorcode=0
	local border=-5
	local s1 s2 s3 flash_free disc_free rc

	[ -d "$DIR_DATABASE" ] || return 0
	[ -e "$DIR_DATABASE/USER/login/meta_index" ] || return 0
	[ -s "$DIR_DATABASE/USER/login/meta_index" ] || return 0

	_log do $funcname daemon info "reason: '$reason'"

	case "$reason" in
		'force'|'remove_old_stuff'|'profile_added_or_changed'|'tickets_autogenerated'|'netfilter_stop'|'login_update_index_gen_last1')
			[ "$reason" = 'remove_old_stuff' ] && border=-999	# accept_shrink
		;;
		*)
			# FIXME! distinguish between backup to FLASH or USB

			if   [ "$reason" = 'prepare_copy_to_server' ]; then
				return 0
			elif bool_true 'system.@system[0].db_backup_force'; then
				border=-999
			else
				_log do $funcname daemon info "ignoring call for '$reason' - use 'force' if needed"
				return 0
			fi
		;;
	esac

	# short check if locking works, otherwise 'db check' fails with sms
	_db lock now "$funcname() $*" || return 1
	_db lock free

	( _db check ) || {
		# forever!
		_db lock forever "locked_forever: DB broken - needs manual fixing"
		_log do $funcname daemon sms "abort, db_check() fails"
		return 1
	}

	_db lock now "$funcname() $*" || return 1
	_system add_ramdisc "$funcname" compressable	# ignored if already exists
	echo "$funcname:$reason" >'/tmp/CRON_OVERLOAD'

	# ramdisc too small?
	if tar -czf "$file_temp" "$DIR_DATABASE" 2>/dev/null ; then
		_db lock free
		_log do $funcname daemon info "[OK] wrote $( _file size "$file_temp" ) bytes to $file_temp"

		local filesize_new="$( _file size "$file_temp" )"
		local filesize_old="$( _file size "$file" )"
		[ -z "$filesize_old" ] && filesize_old=0

		local percentual_change="$( _math percentual_change "$filesize_old" "$filesize_new" )"
		local shrinktext="[ERR] archiv-size shrinks $filesize_old -> $filesize_new = ${percentual_change}%"

		[ $percentual_change -lt 0 ] && {
			_log do $funcname daemon alert "$shrinktext"
		}

		if [ $percentual_change -lt $border ]; then
			_log do $funcname daemon sms "$shrinktext - abort"
			errorcode=1
		else
			s1=$( _file size "$file_temp" )		# bytes
			flash_free=$( _system flash_free )	# kilobytes
			flash_free=$(( $flash_free * 700 ))	# kilobytes -> bytes * 0.7

			[ $flash_free -lt $s1 ] && {
				file_safewrite="/tmp/db_backup_safewrite"
				_log do $funcname daemon info "low flashspace, bend-over safewrite to '$file_safewrite'"
			}

			if mv "$file_temp" "$file_safewrite"; then
				sync
				s2=$( _file size "$file_safewrite" )

				if [ $s1 -eq $s2 ]; then
					_log do $funcname daemon info "[OK] moved $file_temp -> $file_safewrite (sizechange: ${percentual_change}%)"

					[ -e "$file" ] || touch "$file"
					if mv "${file}" "${file}.old"; then
						# do we have enough space?
						[ $(( $( _system flash_free ) * 700 )) -gt $( _file size "$file_safewrite" ) ] || {
							_log do $funcname daemon info "[OK] removing '${file}.old'"
							mv "${file}.old" "${file}" || rm "${file}.old" "${file}"
						}

						if mv "$file_safewrite" "${file}"; then
							sync
							s2=$( _file size "${file}" )

							if [ $s1 -eq $s2 ]; then
								rm "${file}.old"
								_log do $funcname daemon alert "[OK] moved $file_safewrite -> ${file}"
							else
								_log do $funcname daemon sms "[ERR] moved $file_safewrite -> ${file}"
								errorcode=1
							fi
						else
							_log do $funcname daemon sms "[ERR] moving $file_safewrite -> ${file}"
							errorcode=1
						fi
					else
						rm "${file}.old"
						_log do $funcname daemon sms "[ERR] moving ${file} -> ${file}.old"
						errorcode=1
					fi
				else
					_log do $funcname daemon sms "[ERR] moving $file_temp -> $file_safewrite free: $( _system flash_free kilobytes ) kb"
					errorcode=1
				fi
			else
				rm "$file_safewrite"
				_log do $funcname daemon sms "[ERR] moving $file_temp -> $file free: $( _system flash_free kilobytes ) kb"
				errorcode=1
			fi
		fi
	else
		rc=$?
		rm "$file_temp"
		disc_free="$( _system disc_free "$DIR_DATABASE" kilobytes ) kb"
		errorcode=1

		# dont reboot in this state - wait for help
		_log do $funcname daemon sms "[ERR] rc $rc while 'tar -czf \"$file_temp\" \"$DIR_DATABASE\"' - disc_free: $disc_free"
		uci set system.@system[0].avoid_autoreboot='true'

		_db lock free
	fi

	umount "/$funcname"
	rm '/tmp/CRON_OVERLOAD'
	return $errorcode
}

_db_generate_grepable_index()
{
	local funcname='db_generate_grepable_index'
	local option="$1"
	local file='/tmp/USERDB_COPY.cgi.gz'
	local file_index="$DIR_DATABASE/USER/login/meta_index"
	local logprio='info'
	local marker_ok='# OK'
	local size

	[ -e "$file_index" ] || {
		# we cannot work if db_restore() was not fired yet:
		# maybe we are the client? hotfix for 168e3da346b8fa4594f86d0dbd245f3b6cc611fa
		head -n1 '/tmp/USERDB_COPY' | grep -q ^"$marker_ok"$ && rm '/tmp/USERDB_COPY'
		return 1
	}

	[ "$option" = 'check' ] && {
		size=$( _file size "$file" )
		[ $size -gt 0 ] && return 0
	}

	do_index()
	{
		# why tac? it's likely, that we grep for a new login - this should match faster
		# this is >1 magnitude faster than sed-tac
		# fixme! ATM it limits to ~1mb size (4000 lines)
		grep ' mac: ' "$file_index"
		grep -n '' "$file_index" | sort -rn | cut -d: -f2- | head -n 4000
		echo "$marker_ok"
	}

	do_index	>"/tmp/USERDB_COPY.cgi"
	rm 2>/dev/null	"$file"
	gzip		'/tmp/USERDB_COPY.cgi'		# will append .gz
	rm		'/tmp/USERDB_COPY.cgi'

	# is it really a working link? see: cgi-bin-get_userdb.sh
	ls -1 '/www/USERDB_COPY.txt' 2>/dev/null >/dev/null || {
		rm 2>/dev/null 	'/www/USERDB_COPY.txt'
		ln -s "$file" 	'/www/USERDB_COPY.txt'
	}

	size=$( _file size "$file" )
	[ $size -gt 0 ] || logprio='alert'
	_log do $funcname daemon $logprio "[OK] copy size: $size bytes"
}

_db_restore()
{
	local funcname='db_restore'
	local file='/www/cgi-bin/db_backup.tgz'

	_db lock now "$funcname() $*" || return 1

	if [ -e "$file" ]; then
		if [ $( _file size "$file" ) -lt 300 ]; then
			_log do $funcname daemon info "refusing to unarc '$file', seems too small"
		else
			_system add_ramdisc "$DIR_DATABASE" compressable

			_log do $funcname daemon info "removing dir $DIR_DATABASE, unarc of '$file'"
			rm -fR "$DIR_DATABASE" 2>/dev/null

			if tar -C "$( dirname "$DIR_DATABASE" )" -xzf "$file" ; then
				_log do $funcname daemon info "[OK] untar"

				# /database/tmp/...
				[ -d "$( dirname "$DIR_DATABASE" )/tmp" ] && {
					_log do $funcname daemon info "[OK] migrating oldstyle dirstructure"
					mv $( dirname "$DIR_DATABASE" )/tmp/* $( dirname "$DIR_DATABASE" )
					rm -fR $( dirname "$DIR_DATABASE" )/tmp
				}

				# FIXME in backup()
				# /database/database/...
				[ -d "$( dirname "$DIR_DATABASE" )/$( dirname "$DIR_DATABASE" )" ] && {
					_log do $funcname daemon info "[OK] restructure path"
					mv $( dirname "$DIR_DATABASE" )/$( dirname "$DIR_DATABASE" )/* $( dirname "$DIR_DATABASE" )
					rm -fR $( dirname "$DIR_DATABASE" )/$( dirname "$DIR_DATABASE" )
				}

				# match for a single char inclosed in marks, e.g. A=''1''
				grep -qE "''[^']''" "$DIR_DATABASE/USER/device/rows" && {
					# fixed in 157d75a777bd1dcd573aac91cd281260abdb89c8 / 2014jun12
					_log do $funcname daemon alert "repairing DB with doubled quotation marks"
					# no action: A='value'
					# repairing: A=''value'' -> A='value'
					sed -i "/''[^']''/s/''/'/g" "$DIR_DATABASE/USER/device/rows"
				}

				_db generate_grepable_index
			else
				_log do $funcname daemon alert "[ERR] untar of '$file' went wrong - rescheduling"
				touch '/tmp/FREE'

				# dont try again after some tries
				[ $( _system uptime min ) -lt 60 ] && {
					echo >>$SCHEDULER 'rm /tmp/FREE'
					echo >>$SCHEDULER '_db restore'
				}
			fi
		fi
	else
		_log do $funcname daemon info "[ERR] '$file' not found"
	fi

	_db lock free

	# stats are generated via cron.add_collected_userdata_into_db
	# 60 days = 60d * 24h * 4/hour = 5760
	[ $( _file lines "$DIR_DATABASE/USER/device/stats" ) -gt 5760 ] && {
		_log do $funcname daemon alert "removing old stuff, leaving last 45 days"

		_db lock now 'remove_old_stuff_watch_archivsize'
		_watch archivsize "$DIR_DATABASE/USER/device/stats" 4320	# 45 days = 45d * 24h * 4/hour -> 2 megabytes
		_db lock free

		_db backup 'remove_old_stuff'
	}
}

_db_hash()
{
	local hash="$( echo -n "$1" | md5sum )"
	echo "${hash%% *}"
}

_db_user_macenabled_comment_get()
{
	local mac="$1"

	# e.g.:
	# 398313da5cc16596a9babb7ea25be762  mac: 00:16:e3:b9:e8:64 = Laptop Mario
	#
	# mac-entries can be doubled during db_restore() -> output_grepable_index()
	set -- $( fgrep -m 1 -hs "mac: $mac" '/tmp/USERDB_COPY' "$DIR_DATABASE/USER/login/meta_index" )

	while shift; do {
		case "$1" in
			'')
				return 1
			;;
			'mac:')
				shift 3
				echo "$@"
				return 0
			;;
		esac
	} done
}

_db_user()			# poormens_db: each line has: ID=<integer>;A="";B="";C="";D="";...;   	# autocreated is ID = linenumber = index
{
	local funcname="db_user"
	local TABLE="$1"
	local ACTION="$2"
	local ID="$3"		# is set to 'autoid' when action is 'add'
	local OPTION="$4"
	local OPTION2="$5"
	local OBJ= ELEMENTS= REWRITE_VARS= SHORT_VAR= N= LIST= VALUE= FILL=

	case "$TABLE" in
		profile) ELEMENTS="NAME COMMENT AUTOGENERATE TIME_MODEL MAX_TIME MAX_TRAFFIC MAX_SPEED_UP MAX_SPEED_DOWN LANDING_URL COST CURRENCY" ;;
		login)   ELEMENTS="PROFILE_ID COMMENT USERNAME PASSWORD DEVICE_QUANTITY INSTALLED FUZZY USED" ;;
		device)  ELEMENTS="USER_ID MAC DEVTYPE LANG FIRSTSEEN LASTSEEN USED_TRAFFIC USED_TIME USED_TRAFFIC_TODAY USED_TIME_TODAY ISOLATION" ;;
		*)
			echo "Usage: _db user <table> <action>"
			echo "       _db user profile|login|device show [<id>|last|\"elementA elementB ... elementN\"]"
			echo "       _db user profile|login|device list [last <num>|reverse] | linecount | add autoid ... | del <id>|update <id> ..."
			echo "       _db user profile|login|device query ( profile_id <id> | hash2id <hash> | string2id <string> )"
			echo
			echo "       _db user login index_gen [last <num>]"
			return 1
		;;
	esac

	local DIR="$DIR_DATABASE/USER/$TABLE"
	mkdir -p "$DIR"

	case "$ACTION" in
		query)
			case "$ID" in
				profile_id)
					ID="string2id"
					OPTION="A='$OPTION';"		# fixme!
				;;
			esac

			case "$ID" in
				hash2id)
					[ -e "$DIR/meta_index" ] || return 1
					local HASH="${OPTION}"
					# must be compatible with used hash-algo in db_hash()
					[ ${#HASH} -eq 32 ] || return 1
					local cachefile="/tmp/dbcache/hash2id_$HASH"

					cat "$cachefile" 2>/dev/null || {
						mkdir -p '/tmp/dbcache'
						touch "$cachefile"	# better would be to wait if the same hash is queried during sed-call

						if [ "$OPTION2" = "last" ]; then
							# this path seems unused
							sed -n "/$HASH/{=;q}" "$DIR/meta_index" | tail -n1 >"$cachefile"
						else
							# quit after first match?
							sed -n "/$HASH/{=;q}" "$DIR/meta_index" >"$cachefile"
						fi

						cat "$cachefile"

						# exists and >0 bytes? only cache valid entries
						[ -s "$cachefile" ] || rm "$cachefile"
					}
				;;
				string2id)
					[ -e "$DIR/rows" ] || return 1
					local STRING="$OPTION"

					if   [ "$OPTION2" = "last" ]; then
						sed -n "/$STRING/=" "$DIR/rows" | tail -n1
					elif [ "$OPTION2" = "all" ]; then
						sed -n "/$STRING/=" "$DIR/rows"
					else
						sed -n "/$STRING/{=;q}" "$DIR/rows"		# quit after first match
					fi
				;;
				string2id_list)
					[ -e "$DIR/rows" ] || return 1
					local STRING="$OPTION"
					sed -n "/$STRING/=" "$DIR/rows"
				;;
			esac
		;;
		index_gen)
			_db lock now "$funcname() $*" || {
				# FIXME! why is 'index_gen' fired that often?
				case "$( _db lock reason )" in
					*' index_gen  '*)
						_log do $funcname daemon alert "[OK] simulate success for '$*', full 'index_gen' already in progress"
						return 0
					;;
				esac

				return 1
			}

			local INDEX_PRODUCTION="$DIR/meta_index"
			local INDEX="$INDEX_PRODUCTION.temp"
			cp "$INDEX_PRODUCTION" "$INDEX"

			local LOGIN_ID USERNAME PASSWORD FUZZY HASH HASH_INPUT LIST_HASH_INPUT
			local REST_USERNAME REST_PASSWORD LIST_LOGINS HOST LIST_HOSTS
			local USERNAME_CHAR1_LOWER USERNAME_CHAR1_UPPER PASSWORD_CHAR1_LOWER PASSWORD_CHAR1_UPPER
			local H1 H2 H3 H4 H5 H6 H7 H8
			local is_mac j

			is_macaddress()
			{
				case "$1" in
					[0-9a-f][0-9a-f][:-]*) return 0 ;;
							    *) return 1 ;;
				esac
			}

			is_5digits()
			{
				case "$1" in
					[0-9][0-9][0-9][0-9][0-9]) return 0 ;;
								*) return 1 ;;
				esac
			}

			create_index()
			{
				LIST_LOGINS="$( _db user login list ${ID:-all} $OPTION )"
				j=$( _list count_elements "$LIST_LOGINS" )
				[ $j -gt 32 ] && {
					_log do db_create_index daemon alert "start: $j elements"
				}

				for LOGIN_ID in $LIST_LOGINS; do {

					USERNAME=
					eval $( _db user login show "$LOGIN_ID" 'USERNAME PASSWORD FUZZY DEVICE_QUANTITY COMMENT' )

					[ -z "$USERNAME" ] && {
						echo "#"
						continue
					}

					case "$DEVICE_QUANTITY" in
						0|-1|-2|-3)
							echo "#"
							continue
						;;
					esac

					if is_macaddress "$USERNAME"; then
						is_mac="$USERNAME"
					else
						is_mac=
					fi

					if [ -n "$is_mac" ]; then
						LIST_HOSTS="$PASSWORD"

						if [ -z "$LIST_HOSTS" ]; then
							LIST_HASH_INPUT="$USERNAME"
						else
							if is_5digits $HOST; then		# this was an autogenerated password
								LIST_HASH_INPUT="$USERNAME"
							else
								for HOST in $LIST_HOSTS; do {
									LIST_HASH_INPUT="${LIST_HASH_INPUT}${USERNAME}${HOST} "
								} done
							fi
						fi

					elif [ -z "$FUZZY" ]; then
						LIST_HASH_INPUT="$USERNAME$PASSWORD"
					else
						REST_USERNAME="$( echo "$USERNAME" | cut -b2-99 )"
						REST_PASSWORD="$( echo "$PASSWORD" | cut -b2-99 )"

						_sanitizer include
						USERNAME_CHAR1_LOWER="$( _sanitizer do "$USERNAME" length:1 lowercase )"
						USERNAME_CHAR1_UPPER="$( _sanitizer do "$USERNAME" length:1 uppercase )"
						PASSWORD_CHAR1_LOWER="$( _sanitizer do "$PASSWORD" length:1 lowercase )"
						PASSWORD_CHAR1_UPPER="$( _sanitizer do "$PASSWORD" length:1 uppercase )"

						H1="${USERNAME_CHAR1_LOWER}${REST_USERNAME}${PASSWORD_CHAR1_LOWER}${REST_PASSWORD}"
						H2="${USERNAME_CHAR1_UPPER}${REST_USERNAME}${PASSWORD_CHAR1_LOWER}${REST_PASSWORD}"
						H3="${USERNAME_CHAR1_LOWER}${REST_USERNAME}${PASSWORD_CHAR1_UPPER}${REST_PASSWORD}"
						H4="${USERNAME_CHAR1_UPPER}${REST_USERNAME}${PASSWORD_CHAR1_UPPER}${REST_PASSWORD}"

						H5="${PASSWORD_CHAR1_LOWER}${REST_PASSWORD}${USERNAME_CHAR1_LOWER}${REST_USERNAME}"
						H6="${PASSWORD_CHAR1_UPPER}${REST_PASSWORD}${USERNAME_CHAR1_LOWER}${REST_USERNAME}"
						H7="${PASSWORD_CHAR1_LOWER}${REST_PASSWORD}${USERNAME_CHAR1_UPPER}${REST_USERNAME}"
						H8="${PASSWORD_CHAR1_UPPER}${REST_PASSWORD}${USERNAME_CHAR1_UPPER}${REST_USERNAME}"

						HASH="$(         _db hash "$H1" )"		# respects spaces in username or password
						HASH="${HASH} $( _db hash "$H2" )"
						HASH="${HASH} $( _db hash "$H3" )"
						HASH="${HASH} $( _db hash "$H4" )"
						HASH="${HASH} $( _db hash "$H5" )"
						HASH="${HASH} $( _db hash "$H6" )"
						HASH="${HASH} $( _db hash "$H7" )"
						HASH="${HASH} $( _db hash "$H8" )"

						echo "$HASH"
						LIST_HASH_INPUT=
					fi

					HASH=
					for HASH_INPUT in $LIST_HASH_INPUT; do {
						HASH="${HASH}$( _db hash "$HASH_INPUT" ) "
					} done

					# append mac-address in plaintext if 'is_mac' was set
					[ -n "$LIST_HASH_INPUT" ] && echo "${HASH}${is_mac:+ mac: $is_mac = $COMMENT }"
				} done
			}

			_stopwatch start $ACTION
			echo "index_gen.ID:${ID}_OPTION:$OPTION" >'/tmp/CRON_OVERLOAD'

			# e.g.:
			# _db user login index_gen
			# _db user login index_gen last 1
			# _db user login index_gen lock "$LOGIN_ID"
			#
			# $ID     = last|lock
			# $OPTION = 1 or $LOGIN_ID

			case "$ID" in
				'')
					create_index >"$INDEX"
				;;
				lock)
					sed -i "${OPTION}s/^.*/# locked/" "$INDEX"
				;;
				*)
					create_index >>"$INDEX"		# append
				;;
			esac

			rm "/tmp/CRON_OVERLOAD"
			_stopwatch stop "$ACTION" quiet "$( _db user login list linecount )" "tickets"

			if [ $( _file size "$INDEX" ) -gt 0 ]; then		# fixme! lowram?
				if [ "${ID} ${OPTION}" = "last 1" ]; then
					_db lock free
					echo >>$SCHEDULER '_db backup index_generated_last1'
				else
					if mv "$INDEX" "$INDEX_PRODUCTION"; then
						_db lock free
						_log do $funcname daemon info "$ACTION: wrote '$INDEX' -> '$INDEX_PRODUCTION'"
						_db backup "index_generated_full"
					else
						_db lock free
						_log do $funcname daemon sms "$ACTION: [ERR] during mv '$INDEX' -> '$INDEX_PRODUCTION'"
						touch '/tmp/FREE'
					fi
				fi
			else
				_log do $funcname daemon sms "$ACTION: '$INDEX' 0 bytes - removing"
				rm "$INDEX"

				_db lock free
			fi

			_db generate_grepable_index
		;;
		list)
			[ -e "$DIR/rows" ] || return 1

			case "$ID" in
				all)
					sed -n '/./=' "$DIR/rows"
				;;
				linecount)
					fgrep -c 'A=' "$DIR/rows"
				;;
				last)
					sed -n '/A=/=' "$DIR/rows" | tail -n ${OPTION:-1}
				;;
				first)
					sed -n '/A=/=' "$DIR/rows" | head -n ${OPTION:-1}
				;;
				reverse)
					sed -n '/A=/=' "$DIR/rows" | sed '1!G;h;$!d'
				;;
				range)
					local RANGE_START="$OPTION"
					local RANGE_END="$OPTION2"

					[ "$RANGE_END" -le "$RANGE_START" ] && return 1

					sed -n '/A=/=' "$DIR/rows" | sed -n "/^${RANGE_START}$/,/^${RANGE_END}$/p"
				;;
				*)
					sed -n '/A=/=' "$DIR/rows"
				;;
			esac
		;;
		show)						# fixme! idea: always write userwish/$OPTION in output, e.g. USERNAME=;PASSWORD=;
			[ -e "$DIR/rows" ] || return 1

			[ "$ID" = "last" ] && {
				ID="$( sed -n '$=' "$DIR/rows" )"
			}

			table_element_is_part_of_user_wish_or_wanted ()
			{
				case "$OPTION" in
					      "") return 0 ;;
					*"$OBJ"*) return 0 ;;
					       *) return 1 ;;
				esac
			}

			for OBJ in $ELEMENTS; do {

				case "$SHORT_VAR" in
					A) SHORT_VAR="B" ;;
					B) SHORT_VAR="C" ;;
					C) SHORT_VAR="D" ;;
					D) SHORT_VAR="E" ;;
					E) SHORT_VAR="F" ;;
					F) SHORT_VAR="G" ;;
					G) SHORT_VAR="H" ;;
					H) SHORT_VAR="I" ;;
					I) SHORT_VAR="J" ;;
					J) SHORT_VAR="K" ;;
					K) SHORT_VAR="L" ;;
					*)
						SHORT_VAR="A"

						table_element_is_part_of_user_wish_or_wanted && {
							OBJ="ID=${ID};${OBJ}"
							REWRITE_VARS="${REWRITE_VARS}s/${FILL}${SHORT_VAR}=/${FILL}${OBJ}=/;"
						}

						FILL=";"
						continue
					;;
				esac

				table_element_is_part_of_user_wish_or_wanted && {
					REWRITE_VARS="${REWRITE_VARS}s/${FILL}${SHORT_VAR}=/${FILL}${OBJ}=/;"
				}

				FILL=";"				
			} done

			sed -n "${ID}{${REWRITE_VARS}p;q}" "$DIR/rows"		# fixme! return ERROR on nonexisting line
		;;
		del)
			_db lock now "$funcname() $*" || return 1
			sed -i "${ID}s/^.*/#/" "$DIR/rows"
			_db lock free
		;;
		add|update)				# fixme! if "add" is used, ID=<integer> is not in line?
			_db lock now "$funcname() $*" || return 1

			local USERNAME profile_name=

			case "$ACTION" in
				add) 	N=3 ;;		# args are without ID (is autogenerated)
				update) N=4 ;;
			esac

			is_macaddress()
			{
				local hex="a-fA-F0-9"
				local fs=":-"

				case "$1" in
					[$hex][$hex][$fs][$hex][$hex][$fs][$hex][$hex][$fs][$hex][$hex][$fs][$hex][$hex][$fs][$hex][$hex]) return 0 ;;
					*) return 1 ;;
				esac
			}

			SHORT_VAR=
			for OBJ in $ELEMENTS; do {
				eval "VALUE=\"\${$N}\""

				case "${TABLE}_${OBJ}" in
					login_USERNAME)
						is_macaddress "$VALUE" && {
							VALUE="$( _sanitizer do "$VALUE" lowercase mac )"
							USERNAME="$VALUE"
						}
					;;
					login_PROFILE_ID)
						test -n "$VALUE" && {
							# FIXME! too expensive...
							profile_name="$( _db user profile show "$VALUE" 'NAME' | sed -n "s/^.*NAME='\(.*\)';B=.*/\1/p" )"

							case "$profile_name" in
								'room '*)
									# e.g. 'room 231'
								;;
								*)
									profile_name=
								;;
							esac
						}
					;;
				esac

				case "${VALUE}${TABLE}_${OBJ}" in				# fixme! this a hack? (this ask's for an empty "$VALUE"!)
					login_USERNAME)
						if [ -n "$profile_name" ]; then
							# 'room 231' -> 231
							VALUE="${profile_name#* }"	# should set system.@weblogin[0].auth_type=roomnuber
						else
							VALUE="$( _random_username do )"
						fi

						profile_name=
					;;
					nonelogin_USERNAME)
						VALUE=	# special: value 'none' forces an empty username-string (for sms/simple credentials)
					;;
					login_PASSWORD)
						[ -n "$USERNAME" ] || {
							case "$CONFIG_PROFILE" in
								shankar*)
									VALUE="$( _math random_integer 1 9999 fillup )"
								;;
								leonardo*)
									VALUE="$( _math random_integer 1 999999 fillup )"
								;;
								*)
									VALUE="$( _math random_integer 1 99999 fillup )"
								;;
							esac
						}
					;;
					login_INSTALLED)
						VALUE="$( _system date unixtime )"
					;;
				esac

				case "$SHORT_VAR" in
					A) SHORT_VAR="B" ;;
					B) SHORT_VAR="C" ;;
					C) SHORT_VAR="D" ;;
					D) SHORT_VAR="E" ;;
					E) SHORT_VAR="F" ;;
					F) SHORT_VAR="G" ;;
					G) SHORT_VAR="H" ;;
					H) SHORT_VAR="I" ;;
					I) SHORT_VAR="J" ;;
					J) SHORT_VAR="K" ;;
					K) SHORT_VAR="L" ;;
					*) SHORT_VAR="A" ;;
				esac

				LIST="${LIST}$SHORT_VAR='$VALUE';"
				N=$(( $N + 1 ))
			} done

			case "$ACTION" in
				add)
					echo "$LIST" >>"$DIR/rows"
				;;
				update)
					local TAB="	"		# sed-field-separator
					sed -i "${ID}s${TAB}^.*${TAB}ID=$ID;$LIST${TAB}" "$DIR/rows"
				;;
			esac

			case "$TABLE" in
				profile)
					# fixme! must be faster
					echo >>$SCHEDULER '_db backup profile_added_or_changed'
				;;
			esac

			_db lock free
		;;
	esac
}

_db_ticketcheck()
{
	local funcname="db_ticketcheck"
	local profile_id="$1"			# id OR auto (=all id's)
	local border="$( uci -q get system.@weblogin[0].ticketstock || echo '128' )"
	local list counter file

	# TODO: makro in loader, e.g. is_numeric
	if _sanitizer do "$profile_id" numeric check ; then
		list="$profile_id"
	else
		list="$( _db user profile list )"
	fi

	echo "$funcname" >'/tmp/CRON_OVERLOAD'

	for profile_id in $list; do {
		if _system maintenance_window_active; then
			counter="$( _db count_unused_logins "$profile_id" )"
		else
			counter="$( _db count_unused_logins "$profile_id" fast )"
		fi

		AUTOGENERATE=
		eval "$( _db user profile show "$profile_id" "AUTOGENERATE NAME" )"

		if [ "$AUTOGENERATE" = "1" ]; then
			file="$DIR_DATABASE/USER/profile/id${profile_id}_counterA"
			if [ -e "$file" ]; then
				read counter <"$file"
			else
				counter=0
			fi

			_log do $funcname daemon debug "only $counter tickets for profile $profile_id ($NAME) in $file"

			while [ $counter -lt $border ]; do {
				_log do $funcname daemon info "found only $counter tickets but $border are needed"
				_db autocreate_tickets_and_send_mail "$profile_id"
				counter=$(( $counter + 32 ))
				_watch counter "$file" increment 32
			} done
		else
			_log do $funcname daemon debug "ignoring profile $profile_id ($NAME) - autogenerate is off"
		fi
	} done

	rm '/tmp/CRON_OVERLOAD'
}

_db_autocreate_tickets_and_send_mail()
{
	local funcname="db_autocreate_tickets_and_send_mail"
	local PROFILE_ID="${1:-$( _db user profile list first )}"	# or list if login-ID's
	local USECASE="${2:-autogenerate_tickets}"			# <autogenerate_tickets|existing_tickets>
	local logprio="alert"						# fixme! later: sms?

	USERNAME=		# otherwise we get empty passwords -> see db()

	local FUNC="db_autocreate_tickets_and_send_mail"
	local TICKET_QUANTITY=32
	local COUNTER NAME LOGIN LIST_ID

	case "$USECASE" in
		existing_tickets)
			logprio="alert"

			LIST_ID="$( _sanitizer do "$PROFILE_ID" newlines2spaces )"
			for LOGIN in $LIST_ID; do {					# count ID's + get PROFILE_NAME
				COUNTER=$(( ${COUNTER:-0} + 1 ))
				[ -z "$NAME" ] && {
					eval $( _db user login show $LOGIN "PROFILE_ID" )
					eval $( _db user profile show $PROFILE_ID "NAME" )
				}
			} done
		;;
		autogenerate_tickets)
			eval $( _db user profile show $PROFILE_ID "NAME" )

			ID="$( _db user login query profile_id "$PROFILE_ID" last )"
			eval $( _db user login show "$ID" "DEVICE_QUANTITY FUZZY" )

			case "$DEVICE_QUANTITY" in		# fixme! safe defaults per profile
				'-'*)
					DEVICE_QUANTITY=1
				;;
			esac

			_stopwatch start Generating_${TICKET_QUANTITY}_Tickets
			while [ ${COUNTER:=0} -ne $TICKET_QUANTITY ]; do {
				COUNTER="$(( $COUNTER + 1 ))"
				_db user login add "$PROFILE_ID" "" "" "" "$DEVICE_QUANTITY" "$UNIXTIME" "$FUZZY"
			} done
			_stopwatch stop "Generating_${TICKET_QUANTITY}_Tickets" quiet "${TICKET_QUANTITY}" "tickets"

			_db user login index_gen last $TICKET_QUANTITY
			_db backup "tickets_autogenerated"

			LIST_ID="$( _db user login list last $TICKET_QUANTITY )"	
			COUNTER="$TICKET_QUANTITY"
		;;
	esac

	local PRE="/tmp/tickets_autocreated_$$"
	local FILE_MAIL="$PRE.mail.txt"

	local LOCATION_NAME="$( _weblogin metadata_locationname | sed 's#\\&acute;##' )"	# fixme! profile B01/K80
	local FROM_REAL="$( _translate do "$LANG" wifi_system ) $LOCATION_NAME $( uci get mail.@smtp[0].name )"
	local FROM_MAIL="$( uci get mail.@smtp[0].mail )"
	local RECIPIENT_REAL="$( _translate do "$LANG" administration ) $LOCATION_NAME"
	local RECIPIENT_MAIL="$( uci get system.@admin[0].mail )"

	_log do $funcname daemon $logprio \
		"tickettype: $TICKET_QUANTITY x $NAME" \
		"[OK] Neue Tickets wurden automatisch generiert: $TICKET_QUANTITY x $NAME ($( _log append_info ))"

	local FILE_OVERVIEW="/tmp/$( _pdf filename "overview"		"$TICKET_QUANTITY" "$NAME" )"
	local FILE_LABELS="/tmp/$(   _pdf filename "labels"		"$TICKET_QUANTITY" "$NAME" )"
	local FILE_LABELS2="/tmp/$(  _pdf filename "labels_overview"	"$TICKET_QUANTITY" "$NAME" )"
	local FILE_CSV="$PRE.csv"
	local FILE ID
	local UNIXTIME="$( _system date unixtime )"

	_pdf output a4digest		"$LIST_ID" >$FILE_OVERVIEW
	_pdf output a4marker		"$LIST_ID" >$FILE_LABELS
	_pdf output a4marker_digest	"$LIST_ID" >$FILE_LABELS2

	# on router:
	# scp -P 222 .ssh/dropbear_dss_host_key.pub bastian@bwireless.mooo.com:.ssh/authorized_keys.$CONFIG_PROFILE.$HOSTNAME
	# on server:
	# cat .ssh/authorized_keys.* >.ssh/authorized_keys

#	for FILE in "$FILE_OVERVIEW" "$FILE_LABELS" "$FILE_LABELS2"; do {
#		scp -i "/etc/dropbear/dropbear_dss_host_key" -P 222 "$FILE" bastian@bwireless.mooo.com:
#	} done

	_weblogin ticket_mail_text "$NAME" >$FILE_MAIL
	echo "$( _translate do "$LANG" wifi_system ) ($( _translate do "$LANG" overall filename ): $COUNTER) $( _translate do "$LANG" in_an_overview )" >$FILE_OVERVIEW.desc
	echo "$( _translate do "$LANG" wifi_system ) ($( _translate do "$LANG" overall filename ): $COUNTER) $( _translate do "$LANG" for_standard_labels )" >$FILE_LABELS.desc
	echo "$( _translate do "$LANG" protocol )/$( _translate do "$LANG" overview filename ) $( _translate do "$LANG" for_standard_labels )" >$FILE_LABELS2.desc

	for RECIPIENT_MAIL in $( _db list_mail_recipients ); do {
		_mail send "$FROM_REAL" "$FROM_MAIL" "$RECIPIENT_REAL" "$RECIPIENT_MAIL" "$FILE_MAIL" "" "" "" "$FILE_OVERVIEW $FILE_LABELS $FILE_LABELS2"
	} done

	for FILE in $FILE_MAIL $FILE_OVERVIEW $FILE_OVERVIEW.desc $FILE_LABELS $FILE_LABELS.desc $FILE_LABELS2 $FILE_LABELS.desc $FILE_CSV; do {
		[ -e "$FILE" ] && rm "$FILE"
	} done
}

_db_statistics_send_mail()
{
#	_netfilter user_dataretention_needed || return 0

	local funcname='db_statistics_send_mail'
	local mode="$1"		# daily, weekly
	local time="$2"		# yesterday, today...
	local i=0
	local temp="/tmp/$funcname.temp"
	local list_recipients

	local FROM_REAL="$( _translate do "$LANG" wifi_system ) $LOCATION_NAME $( uci get mail.@smtp[0].name )"
	local FROM_MAIL="$( uci get mail.@smtp[0].mail )"
	local RECIPIENT_REAL="$( _translate do "$LANG" administration ) $LOCATION_NAME"
	local RECIPIENT_MAIL="$( uci get system.@admin[0].mail )"
	local FILE_MAIL="/tmp/$funcname.$$"

	daily_out()
	{
		local i="$1"
		while [ $i -gt 0 ]; do {
			cron.db_generate_statistics daily "-$i" 'short'
			i=$(( $i - 1 ))
			tail -n1 "$temp" | grep -q ^'Sun' && echo '---'
		} done
	}

	echo "$funcname:$mode" >'/tmp/CRON_OVERLOAD'

	case "$mode" in
		weekly_report)
			list_recipients="$( _db list_mail_recipients admin ) $( _db list_mail_recipients admin kalua )"

			daily_out 7 >"$temp"
			/usr/sbin/cron.db_generate_statistics 'weekly' '-7' 'short2' "$temp" >"$FILE_MAIL"
			rm "$temp"
		;;
		monthly_report)
			list_recipients="$( _db list_mail_recipients admin ) $( _db list_mail_recipients admin kalua )"

			daily_out 31 >"$temp"
			/usr/sbin/cron.db_generate_statistics 'monthly' '-31' 'short2' "$temp" >"$FILE_MAIL"
			rm "$temp"
		;;
		*)
			list_recipients="$( _db list_mail_recipients admin )"

			/usr/sbin/cron.db_generate_statistics "$mode" "$time" >"$FILE_MAIL"
		;;
	esac

	for RECIPIENT_MAIL in $( _list uniq "$list_recipients" ); do {
		_mail send "$FROM_REAL" "$FROM_MAIL" "$RECIPIENT_REAL" "$RECIPIENT_MAIL" "$FILE_MAIL"
	} done

	rm "$FILE_MAIL" '/tmp/CRON_OVERLOAD'
}

_db_import()
{
	local funcname="db_import"
	local file="$1"			# .csv with: "lastname","firstname" / codepage 8859-15
	local profile_id="${2:-1}"
	local devices_per_login="$3"
	local fuzzy="1"
	local comment line firstname lastname

	while read line; do {

		lastname="$(  echo "$line" | cut -d',' -f1 )"
		firstname="$( echo "$line" | cut -d',' -f2 )"
		eval lastname=$lastname
		eval firstname=$firstname
		comment="$lastname, $firstname"

		username="$( echo $firstname | cut -b 1 ).$lastname"		# Manfred von Ardenne -> "m.von ardenne"
		username="$( _sanitizer do "$username" lowercase )"

		_log do $funcname daemon info "adding '$firstname $lastname' -> $username"
		_db user login add "$profile_id" "$comment" "$username" "" "$devices_per_login" "" "$fuzzy"

	} done <"$file"

	_db user login index_gen
}

_db_list_mail_recipients()
{
	local group="$1"	# e.g. admin | staff = <empty>
	local config_profile="${2:-$CONFIG_PROFILE}"

	build_mail()
	{
		echo "$1@$2.$3"
	}

	case "$config_profile" in
		cupandcoffee*)
			build_mail cupandcoffee.weimar gmail com
			build_mail martina.stue googlemail com
			build_mail info bittorf-wireless de
		;;
		spbansin*)
			build_mail ecklebe he-immobilien de
			build_mail office seeparkbansin de
		;;
		fparkssee*)
			build_mail info ferienpark-scharmuetzelsee de
		;;
		schoeneck*)
			build_mail info.vogtland ifahotels com
		;;
		castelfalfi*)
			build_mail Vittorio.Nocente castelfalfi it
			build_mail operations castelfalfi it
#			build_mail reservations castelfalfi it
			build_mail info bittorf-wireless de
		;;
		leonardo*)
			build_mail info hotel-leonardo de
		;;
		olympia*)
			case "$group" in
				admin)
					build_mail as cans de
				;;
				*)
					build_mail hotel.olympia t-online de
					build_mail as cans de
				;;
			esac
		;;
		vivaldi*)
			build_mail henschel hotel-vivaldi de
		;;
		satama*)
			build_mail info satama-saunapark de
		;;
		monami*)
			build_mail frenzel monami-weimar de
		;;
		ejbw*)
			build_mail peuker ejbweimar de
		;;
		hotello-K80*)
			case "$group" in
				admin)
					build_mail as cans de
					build_mail wlan-ticket cans de
				;;
				*)
					build_mail k80 hotello de
					build_mail wlan-ticket cans de
					build_mail as cans de
				;;
			esac
		;;
		adagio*)
			build_mail mail hotel-adagio de
			build_mail hedi.hedrich t-online de
		;;
		versiliaje*)
			build_mail salvatore.ferrara web de
			build_mail wigo.steinberg gmx de
		;;
		versilia*)
			build_mail weimar ristorante-versilia de
		;;
		xoai*)
			build_mail info hotelxoai com
			build_mail mb mariobehling de
			build_mail info bittorf-wireless de
		;;
		marinabh*)
			build_mail info marina-boltenhagen de
			build_mail info bittorf-wireless de
		;;
		marinapark*)
			build_mail heikelinke web de
		;;
		paltstadt*)
			build_mail info weimar-pension-altstadt de
			build_mail elektrosteinmetz web de
		;;
		galerie*)
			build_mail info leipziger-hof de
			build_mail info bittorf-wireless de
		;;
		aschbach*)
			case "$group" in
				admin)
					build_mail wlan-ticket cans de
					build_mail as cans de
				;;
				*)
					build_mail rezeption berghotel-aschbach de
					build_mail wlan-ticket cans de
					build_mail as cans de
				;;
			esac
		;;
		hotello-B01*)
			case "$group" in
				admin)
					build_mail wlan-ticket cans de
					build_mail as cans de
				;;
				*)
					build_mail b01 hotello de
					build_mail wlan-ticket cans de
					build_mail as cans de
				;;
			esac
		;;
		hotello-H09*)
			case "$group" in
				admin)
					build_mail wlan-ticket cans de
					build_mail as cans de
				;;
				*)
					build_mail h09 hotello de
					build_mail wlan-ticket cans de
					build_mail as cans de
				;;
			esac
		;;
		itzehoe*)
			# hans-juergen.weidlich@stadtwerke-itzehoe.de
			build_mail thies.schroeder-scheel stadtwerke-steinburg de
			build_mail huettendorf stadtwerke-itzehoe de
			# netzbetrieb/nur stoerungen:
			# build_mail juergen.schack stadtwerke-steinburg de
			build_mail l.reschke ehsdruck de
		;;
		apphalle*)
			build_mail info appartementhausamdom de
		;;
		lisztwe*)
			build_mail mail hotel-adagio de
			build_mail mail hotel-liszt de
			build_mail hedi.hedrich t-online de
		;;
		elephant*)
			build_mail elephant.weimar luxurycollection com
		;;
		berlinle*)
			build_mail hotel-berlin-leipzig t-online de
		;;
		dhfleesensee*)
			build_mail Thomas.Hoerning dorfhotel-fleesensee de
			build_mail reservierung dorfhotel-fleesensee de
		;;
		zumnorde*)
			build_mail info hotel-zumnorde de
		;;
		tkolleg*)
			build_mail mail detlefwagner de
			build_mail info bittorf-wireless de
		;;
		shankar*)
			build_mail peerthy gmail com
			build_mail info bittorf-wireless de
		;;
		preskil*)
			build_mail peerthy gmail com
			build_mail nswami lepreskil mu
			build_mail info bittorf-wireless de
		;;
		limona*)
			build_mail reservierung ferienwohnung-limona de
			build_mail info bittorf-wireless de
		;;
		boltenhagenih*|boltenhagendh*)
			case "$group" in
				admin)
					build_mail michael.leirer tui com
					build_mail info bittorf-wireless de
				;;
				*)
					build_mail julia.niehus iberotelboltenhagen de
					build_mail gabriele.jelcho dorfhotelboltenhagen de
				;;
			esac
		;;
		ibfleesensee*)
			build_mail info iberotel-fleesensee de
			build_mail info bittorf-wireless de
		;;
		ilm1*)
			build_mail stefanschlieter gmail com
			build_mail is.1 gmx de
			build_mail info bittorf-wireless de
		;;
		wuensch*)
			build_mail p_s_wuensch t-online de
		;;
		malchowpferde*)
			build_mail info pferdehof-zislow de
			build_mail info malchow-it de
		;;
		malchowpension*)
			build_mail info fackelgarten de
			build_mail info malchow-it de
		;;
		malchow*)
			build_mail info malchow-it de
		;;
		*)
			case "$NODENUMBER" in
				862)
					# zwickauer flitzer
					build_mail alrik.badstuebner web de
				;;
				850|851)
					build_mail info malchow-it de
				;;
				*)
					build_mail info bittorf-wireless de
				;;
			esac
		;;
	esac
}

_db_report()
{
	local object="$1"	# string: device|login
	local username="$2"	# or 'mac' of object = device / or 'hash' of username+password -> _db_hash()
	local password="$3"

	case "$object" in
		device)
			local device_id="$username"

			case "$device_id" in
				*":"*)
					local device_id="$( _db user device query string2id $mac last )"
				;;
			esac

			FIRSTSEEN=
			eval $( _db user device show "${device_id:-999999}" )

			[ -z "$FIRSTSEEN" ] && {
				echo "no database entries for mac: ${mac:-unset_mac}/device_id: ${device_id:-unkown_device_id} yet"
				return
			}

			if [ "$DEVTYPE" = "0" ]; then
				DEVTYPE="wireless"
			else
				DEVTYPE="lan"
			fi

			eval $( _db user login show "$USER_ID" "COMMENT USERNAME PASSWORD PROFILE_ID DEVICE_QUANTITY" )

			if [ "$USERNAME" = "$mac" ]; then
				local authtype="mac-address"
				[ -n "$PASSWORD" ] && {
					authtype="$authtype, restricted to $PASSWORD"
				}
			else
				local authtype="username/password = $USERNAME/$PASSWORD"
			fi

			case "$DEVICE_QUANTITY" in
				"-"*)
					local login_validity="locked/invalid (code: $DEVICE_QUANTITY)"
				;;
				*)
					local login_validity="OK, ${DEVICE_QUANTITY:-undefined} amount"
				;;
			esac

			echo "mac: $MAC ($DEVTYPE) deviceID: $device_id userID: $USER_ID"
			echo "vendor: $( _net mac2vendor "$MAC" short )"
			echo "authentication: $authtype (${COMMENT:-no comment set})"
			echo "validity: $login_validity"

			eval $( _db user profile show "$PROFILE_ID" "NAME COMMENT MAX_TIME MAX_TRAFFIC TIME_MODEL" )
			echo "profile: $NAME (${COMMENT:-no comment set}) profileID: $PROFILE_ID"

			if [ -n "$MAX_TIME" ]; then
				MAX_TIME="limit: $( _stopwatch seconds2humanreadable "$(( $MAX_TIME * 60 ))" )"
			else
				MAX_TIME="unlimited"
			fi

			if [ -n "$MAX_TRAFFIC" ]; then
				MAX_TRAFFIC="limit: $(( MAX_TRAFFIC / 1024 )) megabytes"	# kilobyte -> megabyte
			else
				MAX_TRAFFIC="unlimited"
			fi

			echo "first login: $( _system date unixtime2date "$FIRSTSEEN" )"
			echo "last action: $( _system date unixtime2date "$LASTSEEN" ) (ago ~ $( _stopwatch seconds2humanreadable "$(( $( _system date unixtime ) - $LASTSEEN ))" ))"
			echo "passed time: $( _stopwatch seconds2humanreadable "$(( $LASTSEEN - $FIRSTSEEN ))" ) $( test "$TIME_MODEL" = "1" && echo "($MAX_TIME)" )"
			echo "used time: $( _stopwatch seconds2humanreadable "$USED_TIME" ) $( test "$TIME_MODEL" = "1" || echo "($MAX_TIME)" )"

			echo "traffic overall: $(( ($USED_TRAFFIC + ${USED_TRAFFIC_TODAY:=0}) / 1048576 )).$( echo $(( ($USED_TRAFFIC + $USED_TRAFFIC_TODAY) % 1048576 )) | cut -b1 ) megabytes ($MAX_TRAFFIC)"
			echo "traffic download: $( _sanitizer do "$USED_TRAFFIC" number_humanreadable ) bytes"
			echo "traffic upload: $( _sanitizer do "$USED_TRAFFIC_TODAY" number_humanreadable ) bytes"

			[ "$USED_TRAFFIC_TODAY" = "0" ] && USED_TRAFFIC_TODAY=1
			local ratio="$(( $USED_TRAFFIC / $USED_TRAFFIC_TODAY )).$( echo $(( $USED_TRAFFIC % $USED_TRAFFIC_TODAY )) | cut -b1 )"
			echo "traffic ratio down/up: $ratio:1"
		;;
		login)
			if [ ${#username} -eq 32 ]; then
				local hash="$username"
			else
				local hash="$( _db hash "${username}${password}" )"
			fi

			local user_id="$( _db user login query hash2id "$hash" )"

			[ -z "$user_id" ] && {
				echo "invalid hash/login - checking for username/password"

				user_id="$( _db user login query string2id "C='$username';D='$password'" )"
				[ -z "$user_id" ] && {
					echo "login not found"
					return 1
				}
			}

			# fixme!
			# build abstraction -> also this must return a list of id's
			local device_id="$( _db user device query string2id "A='$user_id';B='" )"

			if [ -z "$device_id" ]; then
				echo "login was never used"
			else
				_db report device "$device_id"
			fi
		;;
	esac
}

_db_count_unused_logins()
{
	local funcname="db_count_unused_logins"
	local wish_id="$1"
	local option="$2"	# e.g. 'fast'

	local list profile_id login_id state j
	local i=0
	local file="$DIR_DATABASE/USER/profile/id${wish_id}_counterA"

	[ "$option" = 'fast' ] && {
		[ -e "$file" ] && read j <"$file"

		if [ ${j:=0} -eq 0 ]; then
			if _system maintenance_window_active ; then
				:	# check deeper/exact
			else
				echo "$j"
				return 0
			fi
		else
			echo "$j"
			return 0
		fi
	}

	list="$( _db user login list reverse )"

	_log do $funcname daemon info "checking profile $wish_id"

	is_used()
	{
		grep -q "A='$1';" "$DIR_DATABASE/USER/device/rows"
	}

	for login_id in $list; do {
		eval $( _db user login show "$login_id" PROFILE_ID )
		[ "$PROFILE_ID" = "$wish_id" ] && {
			if [ "$state" = "1" ]; then
				if is_used "$login_id"; then
					break
				else
					i=$(( $i + 1 ))
				fi
			else
				if is_used "$login_id"; then
					break
				else
					state=1
				fi
			fi
		}
	} done

	_log do $funcname daemon info "unused logins for profile $wish_id: $i"
	echo "$i" >"$file"

	echo "$i"
}

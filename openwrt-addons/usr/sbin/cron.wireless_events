#!/bin/sh
. /tmp/loader

log()
{
	case "$1" in
		'rotate')
			bool_true 'system.@monitoring[0].roaming_stats' && {
				cp '/tmp/IWLOG' "/www/IWLOG.$( _system date unixtime )"
			}

			_watch archivsize '/tmp/IWLOG' 1000 2000
		;;
		*)
			echo "$(date) $1" >>'/tmp/IWLOG'
			_log do iwevent daemon info "$1"
		;;
	esac
}

mac2ipv4()	# TODO: better name
{
	local funcname='mac2ipv4'
	local mac="$1"
	local wifidev="$2"
	local dev='br-mastergate'
	local file="/tmp/ROAMING_remove_host_route_$mac"
	local i=20 signal command
	local server_asked='false'
	local ip=

	while let i-=1; do {
		# ignore IPv6 and show IPv4
		# fe80::221:6aff:fe32:7c1c dev wlan1-1 lladdr 00:21:6a:32:7c:1c STALE
		# 192.168.158.61 dev br-mastergate lladdr 00:21:6a:32:7c:1c STALE
		# 192.168.233.62 dev br-mastergate lladdr 00:21:6a:32:7c:1c REACHABLE
		case "$server_asked" in
			'false')
				set -- $( ip -f inet neigh show dev "$dev" | fgrep "$mac" | grep -v ^'169\.254\.' )
				ip="$1"
			;;
		esac

		case "$ip" in
			*'.'*)
				# arping with max 3 tries
				_net ip_reachable "$ip" 3 "$dev" || {
					server_asked='false'
					ip neigh del $ip dev $dev	# if we have 2 entries and picked the wrong
					_net roaming_mac2ip "$mac" delete_from_local_cache "$ip"
					continue
				}

				case "$ip" in
					"192.168.${NODENUMBER_ROAMING}."*)
						log "$funcname($i) OK: no route-set for $mac/$ip needed: our own HNA4-range - server_asked: $server_asked"
						_netfilter user_probe "$mac" || {
							signal="$( _wifi signal "$wifidev" "$mac" )"

							if   _weblogin login_check  "$mac" ''          "$mac" "$signal"; then
								_netfilter user_add "$mac" "$ip"
							elif _weblogin login_check  "$mac" "$HOSTNAME" "$mac" "$signal"; then
								_netfilter user_add "$mac" "$ip"
							fi
						}
					;;
					'192.168.'*)
						log "$funcname($i) setting host route for alien $ip - server_asked: $server_asked"
						if ip route add "$ip/32" dev $dev; then
							command="NAT_ALIEN_ROAMERS -s $ip -j SNAT --to-source $OLSR_MAIN_IP"
							$IPT -t nat -I $command
							# this file is sourced/executed after 'station del'
							{
								echo "$IPT -t nat -D $command"
								echo "ip route del $ip/32 dev $dev"
								echo "rm $file"
							} >"$file"
						else
							# TODO: remove old route and try again? e.g. 'RTNETLINK answers: File exists'
							_log do $funcname daemon alert "failed to add route for $ip / $dev"
							continue
						fi
					;;
					''*)
						_log do $funcname daemon info "wrong IP: $mac/$ip"
						continue
					;;
				esac

				# FIXME! report ip, if 'server_asked' failed - but how to set 'expires'?
				echo "$ip"
				return 0
			;;
			*)
				# not found in arp-cache, try to ask server (only once)
				if [ "$server_asked" = 'false' ]; then
					server_asked='true'
					ip="$( _net roaming_mac2ip "$mac" )"
					[ -n "$ip" ] && server_asked='true:OK'
				else
					sleep 1
				fi
			;;
		esac
	} done

	if iw dev $wifidev station get $mac >/dev/null; then
		log "$funcname($i) failed to get IP for $mac (still connected - kicking now)"
		_wifi kick "$mac" "$wifidev"
	else
		log "$funcname($i) station $mac lost - giving up"
	fi
}

worker()
{
	local wifidev="$1"	# e.g. 'wlan0-1'
	local mode="$2"		# e.g. 'new' or 'del'
	local mac="$3"
	local ip signal signal_try=5
	local kickmarker="$TMPDIR/kicked_low_signal_$mac-$wifidev"
	local txt="worker($$) dev:$wifidev ch:$( _wifi channel $wifidev ) MODE: $mode MAC: $mac"

	case "$mode" in
		'new')
			if [ -e "$kickmarker" ]; then
				signal=-2				# simulate 'very good'
			else
				while [ $signal_try -gt 0 ]; do {
					# e.g. '-87' or '0'
					signal="$( _wifi signal "$wifidev" "$mac" )"
					if [ ${signal:-0} -eq 0 ]; then
						signal_try=$(( signal_try - 1 ))
					else
						break
					fi
				} done
			fi

			log "$txt - signal: '$signal' try: $signal_try"

			# TODO: different border for 2/5ghz
			# TODO: we must check signal regulary
			bad_signal()
			{
				test $1 -lt -73				# good = 0 or -1 ... -73
			}

			if bad_signal "${signal:=-1}"; then
				touch "$kickmarker"
				_wifi kick "$mac" "$wifidev"
				log "$txt - KICKED early signal: '$signal'"
			else
				ip="$( mac2ipv4 "$mac" "$wifidev" )"
				[ "$signal" = '0' ] && signal="$( _wifi signal "$wifidev" "$mac" )"

				txt="$txt - ip: '$ip' signal: '$signal'"
				log "$txt"
			fi
		;;
		'del')
			if [ -e "/tmp/ROAMING_remove_host_route_$mac" ]; then
				log "$txt - alien: deleting route"
				. "/tmp/ROAMING_remove_host_route_$mac"
			else
				log "$txt - native (no route del)"
			fi

			log rotate
		;;
	esac
}

active_ap_devices()	# e.g. ' wlan0 wlan1-1 wlan1-2 '
{
	cat "$TMPDIR/WIFI_DEVS_AP" 2>/dev/null || {
		grep ^'interface=' /var/run/hostapd-phy[0-3].conf | cut -d'=' -f2 | while read dev; do echo -n " $dev "; done
	}
}

stop()
{
	[ -e '/tmp/IWLOG' ] && {
		iw reg set 00
		iw reg set US
	}
}

if   [ -n "$INCLUDE" ]; then
	:
elif [ -z "$( _wifi get any mode ap )" ]; then
	_log do check_ap daemon info '[OK] exit, no wifi AP configured'
	INCLUDE='exit'
else
	# needed for SNAT later
	OLSR_MAIN_IP="$( uci get olsrd.@olsrd[0].MainIp )"
	[ -z "$OLSR_MAIN_IP" ] && OLSR_MAIN_IP="${LANADR:-$WANADR}"

	log "start listening on '$( active_ap_devices )' PID: $$ OLSR_MAIN_IP: $OLSR_MAIN_IP"
fi

[ -z "$INCLUDE" ] && {
	PIDS_IW_BEFORE="$( pidof iw )"

	iw event | while read LINE; do {
		let COUNTER+=1

		case "$PID_IW" in
			'')
				# during first run, get real PID of 'iw' for killing it later
				for PID_IW in $( pidof iw ); do {
					_list contains_element "$PIDS_IW_BEFORE" "$PID_IW" || break
				} done
			;;
		esac

		[ -e '/tmp/DEBUG' ] && log "DEBUG: $LINE"

		case "$LINE" in
			*': del station '*|*': new station '*)
				# wlan0-1: del station 00:21:6a:32:7c:1c
				# wlan0: new station dc:9f:db:02:b8:ee
				case "$( active_ap_devices )" in
					*" ${LINE%: *} "*)
						set -- $LINE
						log "EVENT $COUNTER: '$LINE'"
						worker "${1%:*}" "$2" "$4"
					;;
				esac

				[ $( _stopwatch stop '/tmp/CRON_LASTCALL' interim,nolog,seconds ) -gt 3600 ] && {
					_system crashreboot 'cron_died'
				}
			;;
			'regulatory domain change: set to '*)
				# e.g. iw reg set 00; iw reg set US
				# TODO: find better method
				log "stopped by user via regset, stopping iw: $PID_IW"
				rm "$TMPDIR/kicked_low_signal_"*
				kill $PID_IW
				break
			;;
		esac
	} done

	RC=$?
	test $RC -eq 0 || {
		[ "$( tail -n1 '/tmp/IWLOG' )" = 'stopped by user via regset' ] || {
			_log do iwevent daemon alert "unexpected event loop exit, rc: $RC"
		}
	}
}
